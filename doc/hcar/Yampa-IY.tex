% Yampa-IY.tex
\begin{hcarentry}[updated]{Yampa}
\report{Ivan Perez}%05/16
\label{yampa}
\makeheader

Yampa (Github: \href{http://git.io/vTvxQ}{http://git.io/vTvxQ}, Hackage:
\href{http://goo.gl/JGwycF}{http://goo.gl/JGwycF}), is a Functional Reactive
Programming implementation in the form of a EDSL to define \emph{Signal
Functions}, that is, transformations of input signals into output signals (aka.
\emph{behaviours} in other FRP dialects). 

Yampa systems are defined as combinations of Signal Functions. The core of
Yampa includes combinators to create constant signals, apply  pointwise (or
time-wise) functions to signals, access the running time of a signal function,
introduce delays and create loopbacks (carrying present output as future
input). These systems can also be dynamic: their structure can change by using
\emph{switching} combinators, which enable the application of a different
signal function at some point in the execution. Combined with combinators to
deal with signal function collections, this enables a form of dynamic FRP in
which new signals can be introduced, frozen, unfrozen, removed and altered at
will.

Yampa is designed to guarantee \emph{causality}: the value of an output signal
at a time $t$ can only depend on values of input signals at times $[0,t]$.
Yampa restricts access to other signals only to the immediate past, by letting
signals functions carry \emph{state} for the future.  FRP signal functions
implement the Arrow and ArrowLoop typeclasses, making it possible to
use both the arrow notation and arrow combinators. A suitable thinking model
for FRP in Yampa is that of signal processing, in which components (signal
functions) transform signals based on their present value and the component's
internal state. Components can be serialized, applied in parallel, etc.

Unlike other implementations of FRP, Yampa enforces a strict separation of
effects and pure transformations. All IO code must exist outside the Signal
Functions, making Yampa systems easier to reason about and debug.

Yampa has been used to create both free/open-source and commercial games.
Examples of the former include Frag (\href{http://goo.gl/8bfSmz}{http://goo.gl/8bfSmz}), a basic
reimplementation of the Quake III Arena engine in Haskell, and Haskanoid
(\href{http://git.io/v8eq3}{http://git.io/v8eq3}), an arkanoid game featuring
SDL graphics and sound with Wiimote \& Kinect support. Examples of the latter
include Keera Studios' Magic Cookies!
(\href{https://goo.gl/0A8z6i}{https://goo.gl/0A8z6i}), a board game for Android
written in Haskell and avaliable via Google Play for Android.

%**<img width=500 src="./androidbreakout.png">
%*ignore
\begin{center}
\includegraphics[width=\linewidth]{html/androidbreakout.png}
% \caption{Screenshot of Yampa game Haskanoid running on Android.}
\end{center}
%*endignore

Guerric Chupin (ENSTA ParisTech), under the supervision of Henrik Nilsson
(Functional Programming Lab, University of Nottingham) has developed Arpeggigon
(\href{https://gitlab.com/chupin/arpeggigon}{https://gitlab.com/chupin/arpeggigon}),
an interactive cellular automaton for composing groove-based music. The aim was
to evaluate two reactive but complementary frameworks for implementing
interactive time-aware applications. Arpeggigon uses Yampa for music
generation, Gtk2HS for Graphical User Interface, jack for handling MIDI I/O,
and Keera Hails to implement a declarative MVC architecture, based on
\emph{Reactive Values and Relations} (RVRs).  The results have been written up
in an application paper, \emph{Funky Grooves: Declarative Programming of
Full-Fledged Musical Applications}, that will be presented at PADL 2017. The
code and an extended version of the paper are publicly available
(\href{https://gitlab.com/chupin/arpeggigon}{https://gitlab.com/chupin/arpeggigon}).

\begin{center}
\includegraphics[width=\linewidth]{arpeggigon.png}
% \caption{Screenshot of Guerric Chupin's Arpeggigon, which combines Reactive Values
% and FRP.}
\end{center}

Extensions to Arrowized Functional Reactive Programming are an active research
topic. Recently, we have published, together with Manuel B\"arenz, a
monadic arrowized reactive framework called Dunai
(\href{https://github.com/ivanperez-keera/dunai}{https://github.com/ivanperez-keera/dunai}),
and a minimal FRP implementation called BearRiver. BearRiver provides all the
features in core Yampa, as well as additional extensions. We have demonstrated
the usefulness of our approach and the compatibility with Yampa by using
BearRiver to compile and execute existing games Haskanoid and Magic Cookies!
for Android without changing the code of such games.

The Functional Programming Laboratory at the University of Nottingham is
working on additional extensions to make Yampa more general and modular,
facilitate other uses cases, increase performance and work around existing
limitations. To collaborate with our research on FRP, please contact Ivan Perez
at \href{mailto:ixp@cs.nott.ac.uk}{ixp@cs.nott.ac.uk} and Henrik Nilsson at
\href{mailto:nhn@cs.nott.ac.uk}{nhn@cs.nott.ac.uk}.

We encourage all Haskellers to participate on Yampa's development by opening
issues on our Github page (\href{http://git.io/vTvxQ}{http://git.io/vTvxQ}),
adding improvements, creating tutorials and examples, and using Yampa in their
next amazing Haskell games.


\end{hcarentry}
